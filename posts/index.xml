<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - My New Hugo Site</title>
        <link>https://rosouly.github.io/rosy.github.io/posts/</link>
        <description>All Posts | My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 09 Jun 2023 20:09:54 &#43;0800</lastBuildDate><atom:link href="https://rosouly.github.io/rosy.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>解决LoveIt代码块超出屏幕范围的问题</title>
    <link>https://rosouly.github.io/rosy.github.io/posts/%E4%B8%BAhugo%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/</link>
    <pubDate>Fri, 09 Jun 2023 20:09:54 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://rosouly.github.io/rosy.github.io/posts/%E4%B8%BAhugo%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/</guid>
    <description><![CDATA[在themes\Lovelt\assets\css\style.scss底部添加下列代码
pre { overflow-x: auto; max-width: 100%; } ]]></description>
</item>
<item>
    <title>K8s入门</title>
    <link>https://rosouly.github.io/rosy.github.io/posts/k8s%E5%85%A5%E9%97%A8/</link>
    <pubDate>Thu, 08 Jun 2023 22:57:51 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://rosouly.github.io/rosy.github.io/posts/k8s%E5%85%A5%E9%97%A8/</guid>
    <description><![CDATA[kubernetes基础概念 Node
Pod 通常一个Pod有一个应用程序（理论上也可以有多个） 每个Pod都有一个IP地址 每当一个Pod die了就会重新建立一个Pod，IP地址并不沿用之前的，而是重新分配 如果访问数据库是通过ip来访问，当ip发生改变，就要手动更改ip，非常麻烦，因此就有了Service这个概念 Service 每一个Pod有一个Service，Service不会随着Pod的声明周期发生变化（解决了ip变化的问题） Ingress 外部网络访问Service的一个接口 config Map 用于存储配置文件，例如数据库的url secret 同样用于存储配置信息，但安全性更高，例如存储数据库的用户名密码 volume 类似于docker的volume用于数据持久化 k8s的voume可以在本地也可以飞本地，例如云服务 Deployment 为了防止downtime，需要对一个Pod创建副本，Deployment可以控制副本数量 StatefulSet Deployment可以创建副本，但是数据库的副本不能由Deployment来创建，因为多个数据库访问同一个volume会有数据不一致的问题，而是要交给StatefulSet来实现 但实际上这仍然很复杂，实践中通常将数据库部署在k8s集群以外 实战 安装minikube 官网：minikube start | minikube (k8s.io)
操作系统：windows
第一个命令的作用：创建目录并下载minikube 第二个命令的作用：将minikube这个目录添加到环境变量中 如果你不想安装到C盘，这里以安装到D:\Program Files (x86)目录下为例：
New-Item -Path &#39;D:\Program Files (x86)&#39; -Name &#39;minikube&#39; -ItemType Directory -Force Invoke-WebRequest -OutFile &#39;D:\Program Files (x86)\minikube\minikube.exe&#39; -Uri &#39;https://github.com/kubernetes/minikube/releases/latest/download/minikube-windows-amd64.exe&#39; -UseBasicParsing $oldPath = [Environment]::GetEnvironmentVariable(&#39;Path&#39;, [EnvironmentVariableTarget]::Machine) if ($oldPath.Split(&#39;;&#39;) -inotcontains &#39;D:\Program Files (x86)\minikube&#39;){ ` [Environment]::SetEnvironmentVariable(&#39;Path&#39;, $(&#39;{0};D:\Program Files (x86)\minikube&#39; -f $oldPath), [EnvironmentVariableTarget]::Machine) ` } 启动minikube 首先电脑中要有docker，运行下列命令（第一次启动需要等待一段时间，因为要拉取镜像）：]]></description>
</item>
<item>
    <title>基于hugo&#43;github page搭建博客</title>
    <link>https://rosouly.github.io/rosy.github.io/posts/my-first-post/</link>
    <pubDate>Thu, 08 Jun 2023 22:57:51 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://rosouly.github.io/rosy.github.io/posts/my-first-post/</guid>
    <description><![CDATA[本地运行 1. 安装 Hugo 首先，从 Hugo 官网 下载并安装适用于您操作系统的 Hugo。
2. 创建新的 Hugo 站点 打开命令行工具，然后输入以下命令创建一个新的 Hugo 站点：
hugo new site my-blog 这将在当前目录下创建一个名为 &ldquo;my-blog&rdquo; 的文件夹，其中包含 Hugo 站点的所有文件和目录。
3. 选择一个主题 浏览 Hugo 主题库，选择一个合适的主题。这里以本博客的主题为例： &ldquo;Loveit&rdquo; ，将其添加到你的站点中：
cd my-blog git init git submodule add https://github.com/dillonzq/LoveIt.git themes/example-theme 将主题添加到站点配置文件 config.toml 中：
theme = &#34;example-theme&#34; 4. 创建内容 使用以下命令创建一篇新的博客文章：
hugo new posts/my-first-post.md 这将在 content/posts 目录下创建一个名为 &ldquo;my-first-post.md&rdquo; 的 Markdown 文件。编辑该文件，添加您的博客内容。
5. 预览博客 在本地预览您的博客，输入以下命令：
hugo server 这将启动一个本地服务器，访问 http://localhost:1313 可以预览您的博客。
部署到 GitHub Pages 1.]]></description>
</item>
<item>
    <title>阅读prompt</title>
    <link>https://rosouly.github.io/rosy.github.io/posts/%E9%98%85%E8%AF%BBprompt/</link>
    <pubDate>Thu, 08 Jun 2023 22:57:51 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://rosouly.github.io/rosy.github.io/posts/%E9%98%85%E8%AF%BBprompt/</guid>
    <description><![CDATA[first prompt（总结） 你是善于总结和提取关键信息的助手。 我会给你一段文本，请你按照下列要求总结文本，最后再给出阅读建议：
总结第一段 总结第二段 总结前面两段，并总结第三段 总结前面三段，并总结第四段 &hellip;&hellip; 总结前面n-1段，并总结第n段，直到总结完全文。 所有的总结都在一句话之内完成。 回答的格式为 第一段总结： 第二段总结： 第三段总结： - 前两段总结： - 本段总结： 第四段总结： - 前三段总结： - 本段总结 &hellip;&hellip; 第n段总结 - 前n-1段总结： - 本段总结：
文本：
4.1 为什么要有虚拟内存？ 本篇跟大家说说内存管理，内存管理还是比较重要的一个环节，理解了它，至少对整个操作系统的工作会有一个初步的轮廓，这也难怪面试的时候常问内存管理。 干就完事，本文的提纲： #虚拟内存 如果你是电子相关专业的，肯定在大学里捣鼓过单片机。 单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。 另外，单片机的 CPU 是直接操作内存的「物理地址」。 在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。 操作系统是如何解决这个问题呢？ 这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。 我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。 进程的中间层 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。 如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。 于是，这里就引出了两种地址的概念： 我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address） 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示： 操作系统是如何管理虚拟地址与物理地址之间的关系？ 主要有两种方式，分别是内存分段和内存分页，分段是比较早提出的，我们先来看看内存分段。 #内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。 分段机制下，虚拟地址和物理地址是如何映射的？ 分段机制下的虚拟地址由两部分组成，段选择因子和段内偏移量。 段选择因子和段内偏移量： 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。 在上面，知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图： 如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。 分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处： 第一个就是内存碎片的问题。 第二个就是内存交换的效率低的问题。 接下来，说说为什么会有这两个问题。 我们先来看看，分段为什么会产生内存碎片的问题？ 我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中： 游戏占用了 512MB 内存 浏览器占用了 128MB 内存 音乐占用了 256 MB 内存。 这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。 如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。 内存分段会出现内存碎片吗？ 内存碎片主要分为，内部内存碎片和外部内存碎片。 内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以不会出现内部内存碎片。 但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部内存碎片的问题。 解决「外部内存碎片」的问题就是内存交换。 可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。 这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。 再来看看，分段为什么会导致内存交换效率低的问题？ 对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。 因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。 所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。 为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页。 #内存分页 分段的好处就是能产生连续的内存空间，但是会出现「外部内存碎片和内存交换的空间太大」的问题。 要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是内存分页（Paging）。 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。 虚拟地址与物理地址之间通过页表来映射，如下图： 页表是存储在内存里的，内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的工作。 而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。 分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？ 内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。 但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对内存分页机制会有内部内存碎片的现象。 如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。 更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。 分页机制下，虚拟地址和物理地址是如何映射的？ 在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。 总结一下，对于一个内存地址转换，其实就是这样三个步骤： 把虚拟内存地址，切分成页号和偏移量； 根据页号，从页表里面，查询对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。 下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图： 这看起来似乎没什么毛病，但是放到实际中操作系统，这种简单的分页是肯定是会有问题的。 简单的分页有什么缺陷吗？ 有空间上的缺陷。 因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。 在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。 这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。 那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。 #多级页表 要解决上面的问题，就需要采用一种叫作多级页表（Multi-Level Page Table）的解决方案。 在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。 我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示： 你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？ 当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。 其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的局部性原理么？ 每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。 如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.]]></description>
</item>
</channel>
</rss>
